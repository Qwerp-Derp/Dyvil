package dyvil.test

include dyvil.Collections
include dyvil.Functions

public class LambdaTest
{
	@FunctionalInterface
	public interface MyFunction<P, R>
	{
		func apply(P par1): R
		
		func andThen<A>(MyFunction<R, A> other): MyFunction<P, A> = x => other(this(x))
	}

	@FunctionalInterface
	public interface IntFunction extends MyFunction<int, int>
	{
		override func apply(int value): int
	}

	public static void repeatClosure(int n, -> void f) = for (var i <- 0 ..< n) f()
	
	private static int staticSum = 0
	
	public static void main([String] args)
	{
		basicTest()
		chainTest()
		closureTest()
		compoundAssignmentTest()
		customSAMTest()
		partialFunctionTest()
		curriedTest()
		typeInferenceTest()
	}
	
	private static void basicTest()
	{
		let nullary1 = () => 1
		let nullary2 = -> long => 2
		let nullary3 = { => 1 }
		let nullary4 = { -> float => 2 }
		// Make sure these compile without errors

		var expected = [ 1 : "A" ]
		var actual = expected.flatMapped((i, s) => [ (i, s) ])

		Main.test("Basic Lambda", expected, actual)
	}
	
	private static void chainTest()
	{
		let fun1 = (int i) -> int => i + 1
		let fun2 = (int i) -> int => i * 2
		let fun12 = fun1.andThen fun2
		let result = (fun12(7))

		Main.test("Function Chain", 16, result)
	}
	
	private static void compoundAssignmentTest()
	{
		var localSum = 0
		let list = List(1, 2, 3)
		list.forEach(i => localSum += i)
		list.forEach(i => staticSum += i)

		Main.test("Compound Assignment (Local)", 6, localSum)
		Main.test("Compound Assignment (Static)", 6, staticSum)
	}
	
	private static void customSAMTest()
	{
		IntFunction intF = i => i * i
		int result = intF(7)

		Main.test("Custom SAM Interface", 49, result)
	}

	private static void closureTest()
	{
		var result = List<String>

		() -> void function1 = function { result += "a" }
		() -> String function2 = function { "b" }

		repeatClosure(3) { result += function2() }

		with<String>("c") { result += $0 } // TODO Remove explicit Type Args

		function1()

		List<String> expected = [ "b", "b", "b", "c", "a" ]
		Main.test("Closures", expected, result)
	}

	private static void partialFunctionTest()
	{
		((int, int) -> int) compareInts = _.compareTo _
		(any -> void) testFun = Main.test("Partial Function Test 1", -1, _)

		testFun(compareInts(1, 2))

		with<String>("A", Main.test("Partial Function Test 2", "A", _)) // Explicit Type Args are required here
	}

	public static void curriedTest()
	{
		(int -> int -> int) add2 = i => j => i + j
		(int -> int -> int -> int) add3 = i => j => k => i + j + k
		(int -> int -> int -> int -> int) add4 = i => j => k => l => i + j + k + l

		Main.test("Curried Test (1 nested level)", 11, add2 1 10)
		Main.test("Curried Test (2 nested levels)", 111, add3 1 10 100)
		Main.test("Curried Test (3 nested levels)", 1111, add4 1 10 100 1000)
	}

	public static void typeInferenceTest()
	{
		var function1 = { int i -> int => i }
		var function2 = { int i, int j => (i, j) }
		var functionCurried = (int i) => (int j) => (i, j)

		Main.test("Type Inference Test (1 Parameter)", type(int -> int).toString, typeOf(function1).toString)
		Main.test("Type Inference Test (2 Parameters", type((int, int) -> (int, int)).toString, typeOf(function2).toString)
		Main.test("Type Inference Test (Curried)", type(int -> int -> (int, int)).toString, typeOf(functionCurried).toString)
	}
}
