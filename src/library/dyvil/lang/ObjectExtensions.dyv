package dyvil.lang

using	dyvil.reflect.Opcodes._

public final class ObjectExtensions
{
	private init() { }

	/**
	 * Tests if the given value is `null`.
	 * @param o the value to check for null-ness
	 *
	 * @return true iff the value is `null`
	 */
	@Intrinsic([ LOAD_0, NULL ])
	public infix boolean isNull(Object o) = o.isNull

	/**
	 * Tests if the given value is not `null`.
	 * @param o the value to check for non-null-ness
	 *
	 * @return true iff the value is not `null`
	 */
	@Intrinsic([ LOAD_0, NONNULL ])
	public infix boolean isNonNull(Object o) = o.isNonNull

	// Structural Equality (equals)
	public infix func ==(Object o1, Object o2): boolean
	{
		if (o1.isNull)	return o2.isNull
		else			return o1.equals o2
	}

	// Reference Equality
	@Intrinsic([ LOAD_0, LOAD_1, ACMPEQ ])
	public infix func ===(Object o1, Object o2): boolean = o1 === o2

	// Structural Inequality (!equals)
	@Intrinsic(value: [ LOAD_0, LOAD_1, INVOKESTATIC, 0, 1, 2, BNOT ], strings: [ "dyvil/lang/Predef", "$eq$eq", "(Ljava/lang/Object;Ljava/lang/Object;)Z" ])
	public infix func !=(Object o1, Object o2): boolean = !(o1 == o2)

	// Reference Inequality
	@Intrinsic([ LOAD_0, LOAD_1, ACMPNE ])
	public infix func !==(Object o1, Object o2): boolean = o1 !== o2

	// Hashing

	public static int hash(Object... args)
	{
		if (args == null) return 0

		var result = 1
		for (var element <- args)
		{
			result = 31 * result + if (element == null) 0 else element.hashCode
		}
		return result;
	}

	public infix func ##(Object o): int = if (o == null) 0 else o.hashCode

	// Comparable

	public infix inline func < <T>(Comparable<T> c1, T c2): boolean = c1.compareTo(c2) < 0

	public infix inline func <= <T>(Comparable<T> c1, T c2): boolean = c1.compareTo(c2) <= 0

	public infix inline func > <T>(Comparable<T> c1, T c2): boolean = c1.compareTo(c2) > 0

	public infix inline func >= <T>(Comparable<T> c1, T c2): boolean = c1.compareTo(c2) >= 0
}
