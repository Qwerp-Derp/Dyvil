package dyvil.lang

import	java.io.PrintStream
import	dyvilx.lang.model.`type`.Type
import	dyvil.annotation.Reified
import	dyvil.util.AutoPrinter
using	dyvil.reflect.Opcodes._

using   java.lang.System.currentTimeMillis => milliTime

/**
 * Experimental Language Features
 */
@dyvil.annotation.Experimental
public final class LanguageFeatures
{
	private init() {}

	// Class and Type

	@Intrinsic([ LOAD_0 ])
	public static T cast<T>(any value) = cast<T>(value)

	public static Class<T> classOf<@Reified(true) T>(T value) = class T

	public static Type<T> typeOf<@Reified T>(T value) = type T

	// Increments

	public static void inc(int^ i, int n = 1) = *i = *i + n

	public static void inc(long^ l, long n = 1L) = *l = *l + n

	public static void inc(float^ f, float n = 1F) = *f = *f + n

	public static void inc(double^ d, double n = 1D) = *d = *d + n

	// Useful Globals

	public static inline R run<R>(-> R f) = f()

	public static infix inline R run<T, R>(T self, T.() -> R f) = f(self)

	public static infix inline T use<T>(T self, T.() -> void f) = self.{ f $0; $0 }

	public static inline R with<T, R>(T receiver, T -> R f) = f(receiver)

	// I/O

	public const String ENDL = System.lineSeparator

	public infix inline func <<(PrintStream stream, any value): PrintStream = stream.{ print value; $0 }

	public static inline func println(AutoPrinter.() -> void closure): void = closure(AutoPrinter)

	// Timing

	public static inline long measureMillis(-> void f) = System.milliTime.{ f(); System.milliTime - $0 }

	public static inline long measureNanos(-> void f) = System.nanoTime.{ f(); System.nanoTime - $0 }

	public static inline (R, long) milliTimed<R>(-> R f) = System.milliTime.{ (f(), System.milliTime - $0) }

	public static inline (R, long) nanoTimed<R>(-> R f) = System.nanoTime.{ (f(), System.nanoTime - $0) }
}
