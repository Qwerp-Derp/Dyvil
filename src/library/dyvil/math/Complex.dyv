package dyvil.math

@LiteralConvertible.FromDouble
@LiteralConvertible.FromTuple
public case class Complex(final double real, final double imag)
{
	public static let i = Complex(0, 1)

	// Conversion Methods

	public static inline func apply(double real): Complex = new Complex(real, 0)

	@OverloadPriority
	public static func apply(double real, double imag): Complex = new Complex(real, imag)

	@BytecodeName("fromPolar")
	public static func apply(double length, double argument): Complex = new Complex(length * Math.cos(argument), length * Math.sin(argument))

	public static implicit inline infix func toComplex(double d): Complex = Complex(d, 0)

	// Basic Operators

	public func length(): double
	{
		let r = this.real
		let i = this.imag
		return Math.sqrt(r * r + i * i)
	}

	public func argument(): double = Math.atan(this.imag / this.real)

	// Prefix Operators

	public prefix func -(Complex c): Complex = Complex(-c.real, c.imag)

	public prefix func ~(Complex c): Complex = Complex(c.real, -c.imag)

	// Infix Operators

	public infix func +(Complex lhs, Complex rhs): Complex = Complex(lhs.real + rhs.real, lhs.imag + rhs.imag)

	public infix func -(Complex lhs, Complex rhs): Complex = Complex(lhs.real - rhs.real, lhs.imag - rhs.imag)

	public infix func *(Complex lhs, Complex rhs): Complex
	{
		let lr = lhs.real
		let li = lhs.imag
		let rr = rhs.real
		let ri = rhs.imag
		return Complex(lr * rr - ri * li, li * rr + lr * ri)
	}

	public infix func /(Complex lhs, Complex rhs): Complex
	{
		let lr = lhs.real
		let li = lhs.imag
		let rr = rhs.real
		let ri = rhs.imag
		let d = 1.0 / (rr * rr + ri * ri)
		return Complex((lr * rr + li * ri) * d, (li * rr - lr * ri) * d)
	}

	public override func toString(): String = this.imag >= 0 ? "\(this.real)+\(this.imag)i" : "\(this.real)\(this.imag)i"
}
